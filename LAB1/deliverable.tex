\documentclass[12]{article}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\author{par4111 \\ Adrià Cabeza, Xavier Lacasa \\ Departament d' Arquitectura de Computadors}
\title{Lab 1: Experimental setup and tools}
\date{\today \\ 2018 - 19 PRIMAVERA}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\lstset{
	frame=tb,language=C,breaklines=true,numbers=none, commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, tabsize=3,   showstringspaces=false,
  columns=flexible, 
}
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Introduction}
In order to do properly this subject, first, we have to introduce some new concepts and hardware and software environment that we will use during this semester to do all laboratory assignments.  The following document contains an introductory approach, step by step introducing those concepts. We will introduce the \textit{Boada} architecture, some of the most important parallelism concepts and several tests to see its effects. 

\section{Experimental setup}
\subsection{Node architecture and memory}

\textit{Boada} is a multiprocessor server located at the Computer Architecture Department divided in different nodes, each of them with different architecture and diffferent uses. \textit{Boada} is composed of 8 nodes (from boada-1 to boada-8) and they can be grouped as the following table: 
\\
\begin{table}[h]
\begin{tabular}{|l|l|l|l|}
\hline
Node name    & Processor generation                & Interactive & Queue name \\ \hline
boada-1      & Intel Xeon E5645                    & Yes         & batch      \\
boada-2 to 4 & Intel Xeon E5645                    & No          & execution  \\
boada-5      & Intel Xeon E5-2620 v2 + Nvidia K40c & No          & cuida      \\
boada-6 to 8 & Intel Xeon E5-2609 v4               & No          & execution2 \\ \hline
\end{tabular}
\end{table}

However in this course we are going to use mainly from boada-1 to boada-4. The easiest way to obtain the information of the hardware used in each node is using the linux commands lscpu and lstopo(~\ref{fig:lstopto2} and ~\ref{fig:lstopto8}). This commands can be easily executed in the boada-1 node (because it is interactive), but if we want to use the other nodes we can use the submit-*.sh script provided by the PAR professors and use the queue system. \\
\medskip

\begin{figure}[h]
\centering  \includegraphics[width=.8\linewidth]{map-2.png}
  \caption{Boada-2 architecture outputed by lstopo.}
  \label{fig:lstopto2}
\end{figure}

\begin{figure}[h]
\centering
  \includegraphics[width=.8\linewidth]{map-8.png}
  \caption{Boada-8 architecture outputed by lstopo.}
  \label{fig:lstopto8}
\end{figure}

After creating the scipts and applying them to each of the nodes, we obtained the following hardware information: 


\begin{table}[h]
\centering    \begin{tabular}{|l||l|l|l|}
    \hline
                                        & boada-1 to boada-4    & boada-5   & boada-6 to boada-8    \\
    \hline\hline
    Number of sockets per node          & 2                     & 2         & 2                     \\
    \hline
    Number of cores per socket          & 6                     & 6         & 8                     \\
    \hline
    Number of threads per core          & 2                     & 2         & 1                     \\
    \hline
    L1-I cache size (per-core)          & 32 KB                 & 32 KB     & 32 KB                 \\    
    \hline
    L1-D cache size (per core)          & 32 KB                 & 32 KB     & 32 KB                 \\
    \hline
    L2 cache size (per-core)            & 256 KB                & 256 KB    & 256 KB                \\
    \hline
    Last-level cache size (per-socket)  & 12 MB                 & 15 MB     & 20 MB                 \\
    \hline
    Main memory  size (per socket)      & 12 GB                 & 31 GB     & 16 GB                 \\
    \hline
    Main memory size (per node)         & 23 GB                 & 63 GB     & 31 GB                 \\
    \hline
    \end{tabular}
\end{table}

\bigskip

The previous table gives us useful information that will be necessary in the future to properly use the \textit{boada} system and understand the parallelism decomposition and time we will get. 

\subsection{Sequential and parallel executions}

More often than not parallelism offers speed-ups in the execution time of applications. Sometimes, however, that extra speed is used to augment the problem size, which would not be possible otherwise.

In the two following sections we are going to see the differences of two different approaches to parallelism, \textbf{strong} and \textbf{weak}, applied to the \textit{pi\_omp.c} program.

\subsubsection{Strong scalability}

Strong scalabilty consists in increasing the numberer of processors while keeping the problem size the same. This reduces the amount of work each processor has to do, which speeds-up the execution.
Nonetheless, the speed-up is bounded by the parallelization of the program and the overhead generated when doing so. Usually a point is reached where adding processors has no further effect on the program or the overhead generated by further parallelizing the program is greater than the added speed-up. 
ARA HEM DE POSAR ELS GRÀFICS PELS DIFERENTS BOADAS PERO NO ELS PUC CREAR, ES GENEREN EN BLANC JKAHSDFUJAHFUJAHFA

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pi_omp-100000000-1-12-3-weak-boada-6.png}
 \caption{ \textit{pi\_omp} with 100000000 weak by boada-6}
  \label{fig:pi_ompboada6}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pi_omp-1000000000-1-12-3-strong-boada-8.png}
 \caption{ \textit{pi\_omp} with 1000000000 strong by boada-8}
 \label{fig:pi_ompboada8}
\end{figure}

\subsubsection{Weak scalability}

Weak scalability takes a different approach. It takes advantage of the additional power gained by parallelizing the program to increase the problem size, so that while the speed-up stays more or less the same, the work done increases.
ARA HEM DE POSAR ELS GRÀFICS PELS DIFERENTS BOADAS PERO NO ELS PUC CREAR, ES GENEREN EN BLANC JKAHSDFUJAHFUJAHF
\section{Experimental setup}
\subsection{Introduction}
The objective of this laboratory is learn how to use Tareador, an environment to analyse the potential parallelilsm that can be obtained when a certain task decomposition is applied to a code. We will introduce how it works and we will experiment and analyse decomposition with a sequential code called 3DFFT.

\subsection{Analysis of task decompositions for 3DFFT}

Once we have seen the basic features in \textit{Tareador} we can now proceed to explore new tasks decompositions for a piece of code. Down below we will incrementally generate five new task decompositions and the potential parallelism ($T_1 / T_\infty$) from the task dependence graph generated by \textit{Tareador}. 
\\
To obtain $T_\infty$ we will assume that each instruction takes one time unit to execute and simulate the execution of the graph with a large number of processors.
 
\begin{figure}[H]
\centering  \includegraphics[width=.8\linewidth, height=14cm, width=6cm]{dependency_graph0.png}
  \caption{Dependency graph for the original version.}
  \label{fig:Depencency0}
\end{figure}


\subsubsection{Version 1}

The first version consists in replacing the task named \texttt{ffts1\_and\_transpositions} with a sequence of finer grained tasks, one for each function invocation inside it.
\\
\begin{lstlisting}
...
    tareador_start_task("0");
    ffts1_planes(p1d, in_fftw);
    tareador_end_task("0");

    tareador_start_task("1");
    transpose_xy_planes(tmp_fftw, in_fftw);
    tareador_end_task("1");

    tareador_start_task("2");
    ffts1_planes(p1d, tmp_fftw);
    tareador_end_task("2");

    tareador_start_task("3");	
    transpose_zx_planes(in_fftw, tmp_fftw);
    tareador_end_task("3");
    
    tareador_start_task("4");
    ffts1_planes(p1d, in_fftw);
    tareador_end_task("4");

    tareador_start_task("5");
    transpose_zx_planes(tmp_fftw, in_fftw);
    tareador_end_task("5");

    tareador_start_task("6");
    transpose_xy_planes(in_fftw, tmp_fftw);
    tareador_end_task("6");
\end{lstlisting}

Once we have created all these tasks, we ... PURO PALO, ja ho faré 

\begin{figure}[H]
\centering  \includegraphics[width=\linewidth, height=22cm, width=5cm]{dependency_graph1.png}
  \caption{Dependency graph for the first version.}
  \label{fig:Depencency1st}
\end{figure}


\subsubsection{Version 2}

The second version, starting from the first one, consists in replacing the definition of tasks associated to function invocations \texttt{ffts1\_planes} with fine-grained tasks defined inside the function body and associated to individual iterations of the k loop.
\\ \medskip
\begin{lstlisting}

void ffts1_planes(fftwf_plan p1d, fftwf_complex in_fftw[][N][N]) {
    int k,j;

    for (k=0; k<N; k++) {
     tareador_start_task("ffts1_planes_loop_k");
     for (j=0; j<N; j++) {
       fftwf_execute_dft( p1d, (fftwf_complex *)in_fftw[k][j][0], (fftwf_complex *)in_fftw[k][j][0]);
     }
     tareador_end_task("ffts1_planes_loop_k");
    }
}


int main(){
...
    tareador_start_task("1");
    transpose_xy_planes(tmp_fftw, in_fftw);
    tareador_end_task("1");

    ffts1_planes(p1d, tmp_fftw);

    tareador_start_task("3");	
    transpose_zx_planes(in_fftw, tmp_fftw);
    tareador_end_task("3");

    ffts1_planes(p1d, in_fftw);

    tareador_start_task("5");
    transpose_zx_planes(tmp_fftw, in_fftw);
    tareador_end_task("5");

    tareador_start_task("6");
    transpose_xy_planes(in_fftw, tmp_fftw);
    tareador_end_task("6");
...
}

\end{lstlisting}

\begin{figure}[H]
\centering  \includegraphics[width=\linewidth , height=13cm, width=13cm ]{dependency_graph2.png}
  \caption{Dependency graph for the second version.}
  \label{fig:Depencency2nd}
\end{figure}


\subsubsection{Version 3}
The third version, starting from the second one, consists in replacing the definition of tasks associated to function invocations \texttt{transpose\_xy\_planes} and \texttt{transpose\_zx\_planes} with fine-grained tasks inside the corresponding body functions and associated to individual iterations of the k loop, similarly it was made in the second version. 
\begin{lstlisting}
void transpose_xy_planes(fftwf_complex  tmp_fftw[][N][N], fftwf_complex in_fftw[][N][N]) {
    int k,j,i;

    for (k=0; k<N; k++) {
     tareador_start_task("transpose_xy_planes_loop_k");
     for (j=0; j<N; j++) {
       for (i=0; i<N; i++)
       {
         tmp_fftw[k][i][j][0] = in_fftw[k][j][i][0];
         tmp_fftw[k][i][j][1] = in_fftw[k][j][i][1];
       }
     }
     tareador_end_task("transpose_xy_planes_loop_k"); 
   }
}

void transpose_zx_planes(fftwf_complex in_fftw[][N][N], fftwf_complex tmp_fftw[][N][N]) {
    int k, j, i;

    for (k=0; k<N; k++) {
    tareador_start_task("transpose_zx_planes_loop_k");
    for (j=0; j<N; j++) {
      for (i=0; i<N; i++)
       {
         in_fftw[i][j][k][0] = tmp_fftw[k][j][i][0];
         in_fftw[i][j][k][1] = tmp_fftw[k][j][i][1];
       }
     }
     tareador_end_task("transpose_zx_planes_loop_k");

    }
}

int main(){
...
    tareador_start_task("init_complex_grid");
    init_complex_grid(in_fftw);
    tareador_end_task("init_complex_grid");

    STOP_COUNT_TIME("Init Complex Grid FFT3D");

    START_COUNT_TIME;

    ffts1_planes(p1d, in_fftw);
    transpose_xy_planes(tmp_fftw, in_fftw);
    ffts1_planes(p1d, tmp_fftw);
    transpose_zx_planes(in_fftw, tmp_fftw);
    ffts1_planes(p1d, in_fftw);
    transpose_zx_planes(tmp_fftw, in_fftw);
    transpose_xy_planes(in_fftw, tmp_fftw);
...
}
\end{lstlisting}


\begin{figure}[H]
\centering  \includegraphics[width=\linewidth , height=13cm, width=13cm  ]{dependency_graph3.png}
  \caption{Dependency graph for the third version.}
  \label{fig:Depencency3rd}
\end{figure}

\subsubsection{Version 4}


\begin{lstlisting}
void init_complex_grid(fftwf_complex in_fftw[][N][N]) {
  int k,j,i;

  for (k = 0; k < N; k++) {
    tareador_start_task("transpose_init_complex_grid_loop_k");
    for (j = 0; j < N; j++) {
      for (i = 0; i < N; i++)
      {
        in_fftw[k][j][i][0] = (float) (sin(M_PI*((float)i)/64.0)+sin(M_PI*((float)i)/32.0)+sin(M_PI*((float)i/16.0)));
        in_fftw[k][j][i][1] = 0;
#if TEST
        out_fftw[k][j][i][0]= in_fftw[k][j][i][0];
        out_fftw[k][j][i][1]= in_fftw[k][j][i][1];
#endif
      }
    }
 
     tareador_end_task("transpose_init_complex_grid_loop_k"); 
 }
}
int main(){
...

    init_complex_grid(in_fftw);
    STOP_COUNT_TIME("Init Complex Grid FFT3D");

    START_COUNT_TIME;

    ffts1_planes(p1d, in_fftw);
    transpose_xy_planes(tmp_fftw, in_fftw);
    ffts1_planes(p1d, tmp_fftw);
    transpose_zx_planes(in_fftw, tmp_fftw);
    ffts1_planes(p1d, in_fftw);
    transpose_zx_planes(tmp_fftw, in_fftw);
    transpose_xy_planes(in_fftw, tmp_fftw);
...
}

\end{lstlisting}

\begin{figure}[H]
\centering  \includegraphics[width=\linewidth , height=13cm, width=13cm  ]{dependency_graph4.png}
  \caption{Dependency graph for the forth version.}
  \label{fig:Dependency4rth}
\end{figure}


\subsubsection{Version 5}
\begin{lstlisting}



\end{lstlisting}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
Version & $T_1 $ & $T_\infty$ & Parallelism \\ \hline
seq     &   &   &             \\ \hline
v1      &   &   &             \\ \hline
v2      &   &   &             \\ \hline
v3      &   &   &             \\ \hline
v4      &   &   &             \\ \hline
v5      &   &   &             \\ \hline
\end{tabular}
\end{table}


\section{Conclusions}

\end{document}
